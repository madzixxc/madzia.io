<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>madzia.io</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #111111;
            overflow: hidden;
        }

        .background {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .text-container {
            position: relative;
            z-index: 2;
            transform-origin: center center;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .text-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .bg-tile {
            position: absolute;
            border-radius: 4px;
            background: linear-gradient(135deg,
                rgba(40, 40, 40, 0.6) 0%,
                rgba(30, 30, 30, 0.6) 50%,
                rgba(20, 20, 20, 0.6) 100%);
            box-shadow: 
                inset 1px 1px 2px rgba(255, 255, 255, 0.1),
                inset -1px -1px 2px rgba(0, 0, 0, 0.3);
            margin: 2px;
        }

        .text-pixel {
            position: absolute;
            border-radius: 2px;
            transition: all 0.3s ease;
            z-index: 2;
            box-shadow: 
                inset 1px 1px 3px rgba(255, 255, 255, 0.6),
                inset -1px -1px 3px rgba(0, 0, 0, 0.6),
                0px 3px 6px rgba(0, 0, 0, 0.4);
            width: calc(100% - 1px);
            height: calc(100% - 1px);
        }
    </style>
</head>
<body>
    <div class="background" id="background"></div>
    <div class="text-container">
        <div class="text-wrapper" id="text-wrapper"></div>
    </div>

    <script>
        const text = 'madzia.io';
        let pixelSize = 20;
        const bgTileSize = 80;
        
        // ASCII representation of each letter
        const letters = {
            'm': [
                '11111',
                '11011',
                '10101',
                '10001',
                '10001'
            ],
            'a': [
                '01110',
                '10001',
                '11111',
                '10001',
                '10001'
            ],
            'd': [
                '11110',
                '10001',
                '10001',
                '10001',
                '11110'
            ],
            'z': [
                '11111',
                '00110',
                '01100',
                '11000',
                '11111'
            ],
            'i': [
                '11111',
                '00100',
                '00100',
                '00100',
                '11111'
            ],
            '.': [
                '00000',
                '00000',
                '00000',
                '01100',
                '01100'
            ],
            'o': [
                '01110',
                '10001',
                '10001',
                '10001',
                '01110'
            ]
        };

        // Vibrant colors for text
        const colors = [
            '#FF0080', // Pink
            '#00FF80', // Cyan
            '#8000FF', // Purple
            '#FF8000', // Orange
            '#00FFFF', // Aqua
            '#FF00FF', // Magenta
            '#FFFF00'  // Yellow
        ];

        function createBgTile(x, y, grid) {
            const tile = document.createElement('div');
            tile.className = 'bg-tile';
            
            // Randomize tile size (smaller variation to prevent overlaps)
            const baseSize = bgTileSize;
            const sizeVariation = 20; // reduced size variation
            const width = baseSize + (Math.random() - 0.5) * sizeVariation;
            const height = baseSize + (Math.random() - 0.5) * sizeVariation;
            
            // Calculate safe position bounds
            const maxPosVariation = (bgTileSize - Math.max(width, height)) / 2;
            const posVariation = Math.max(0, maxPosVariation);
            
            // Try to find a non-overlapping position
            let xPos, yPos;
            let attempts = 0;
            const maxAttempts = 5;
            
            do {
                xPos = x + (Math.random() - 0.5) * posVariation * 2;
                yPos = y + (Math.random() - 0.5) * posVariation * 2;
                attempts++;
            } while (attempts < maxAttempts && isOverlapping(xPos, yPos, width, height, grid));
            
            // Update grid with final position
            const gridX = Math.floor(xPos / bgTileSize);
            const gridY = Math.floor(yPos / bgTileSize);
            grid[`${gridX},${gridY}`] = { x: xPos, y: yPos, width, height };
            
            tile.style.width = `${width}px`;
            tile.style.height = `${height}px`;
            tile.style.left = `${xPos}px`;
            tile.style.top = `${yPos}px`;
            
            return tile;
        }

        function isOverlapping(x, y, width, height, grid) {
            const margin = 2; // minimum space between tiles
            
            // Check nearby grid cells for potential overlaps
            const startGridX = Math.floor((x - width) / bgTileSize);
            const endGridX = Math.ceil((x + width) / bgTileSize);
            const startGridY = Math.floor((y - height) / bgTileSize);
            const endGridY = Math.ceil((y + height) / bgTileSize);
            
            for (let gridY = startGridY; gridY <= endGridY; gridY++) {
                for (let gridX = startGridX; gridX <= endGridX; gridX++) {
                    const key = `${gridX},${gridY}`;
                    const tile = grid[key];
                    if (tile) {
                        // Check if rectangles overlap
                        if (!(x + width + margin < tile.x || 
                            x > tile.x + tile.width + margin || 
                            y + height + margin < tile.y || 
                            y > tile.y + tile.height + margin)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function createTextPixel(x, y, color) {
            const pixel = document.createElement('div');
            pixel.className = 'text-pixel';
            pixel.style.left = `${x}px`;
            pixel.style.top = `${y}px`;
            pixel.style.width = `${pixelSize}px`;
            pixel.style.height = `${pixelSize}px`;
            
            // Create gradient based on the base color
            const rgb = hexToRgb(color);
            const lighter = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)`;
            const darker = `rgba(${Math.max(0, rgb.r - 50)}, ${Math.max(0, rgb.g - 50)}, ${Math.max(0, rgb.b - 50)}, 1)`;
            pixel.style.background = `linear-gradient(135deg, ${lighter} 0%, ${darker} 100%)`;
            
            return pixel;
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function renderBackground() {
            const container = document.getElementById('background');
            container.innerHTML = '';
            
            const grid = {};
            const cols = Math.ceil(window.innerWidth / bgTileSize) + 1;
            const rows = Math.ceil(window.innerHeight / bgTileSize) + 1;

            // Create tiles with collision detection
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const tile = createBgTile(x * bgTileSize, y * bgTileSize, grid);
                    container.appendChild(tile);
                }
            }
        }

        function renderText() {
            const wrapper = document.getElementById('text-wrapper');
            wrapper.innerHTML = '';
            let totalWidth = 0;
            let totalHeight = 5 * pixelSize;

            // Calculate total width
            text.split('').forEach(char => {
                if (!letters[char]) return;
                const pattern = letters[char];
                totalWidth += (pattern[0].length + 1) * pixelSize;
            });

            // Scale to fit viewport
            const maxWidth = window.innerWidth * 0.8;
            const maxHeight = window.innerHeight * 0.5;
            const scaleX = maxWidth / totalWidth;
            const scaleY = maxHeight / totalHeight;
            const scale = Math.min(scaleX, scaleY);

            pixelSize = Math.floor(pixelSize * scale);
            let xOffset = -totalWidth * scale / 2;

            // Render text pixels
            text.split('').forEach(char => {
                if (!letters[char]) return;
                const pattern = letters[char];
                pattern.forEach((row, y) => {
                    for (let x = 0; x < row.length; x++) {
                        if (row[x] === '1') {
                            const color = colors[Math.floor(Math.random() * colors.length)];
                            const pixel = createTextPixel(
                                x * pixelSize + xOffset,
                                y * pixelSize - (totalHeight * scale / 2),
                                color
                            );
                            wrapper.appendChild(pixel);
                        }
                    }
                });
                xOffset += (pattern[0].length + 1) * pixelSize;
            });
        }

        renderBackground();
        renderText();

        // Only resize event, no animations
        window.addEventListener('resize', () => {
            renderBackground();
            renderText();
        });
    </script>
</body>
</html>
