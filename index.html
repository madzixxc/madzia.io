<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>madzia.io</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #111111;
            overflow: hidden;
        }

        .background {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .text-container {
            position: relative;
            z-index: 2;
            transform-origin: center center;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .text-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .bg-tile {
            position: absolute;
            border-radius: 4px;
            background: linear-gradient(135deg,
                rgba(40, 40, 40, 0.6) 0%,
                rgba(30, 30, 30, 0.6) 50%,
                rgba(20, 20, 20, 0.6) 100%);
            box-shadow: 
                inset 1px 1px 2px rgba(255, 255, 255, 0.1),
                inset -1px -1px 2px rgba(0, 0, 0, 0.3);
            margin: 2px;
        }

        .text-pixel {
            position: absolute;
            border-radius: 2px;
            transition: all 0.3s ease;
            z-index: 2;
            box-shadow: 
                inset 1px 1px 3px rgba(255, 255, 255, 0.6),
                inset -1px -1px 3px rgba(0, 0, 0, 0.6),
                0px 3px 6px rgba(0, 0, 0, 0.4);
            width: calc(100% - 1px);
            height: calc(100% - 1px);
        }
    </style>
</head>
<body>
    <div class="background" id="background"></div>
    <div class="text-container">
        <div class="text-wrapper" id="text-wrapper"></div>
    </div>

    <script>
        const text = 'madzia.io';
        let pixelSize = 20;
        const bgTileSize = 80;
        
        // ASCII representation of each letter
        const letters = {
            'm': [
                '11111',
                '11011',
                '10101',
                '10001',
                '10001'
            ],
            'a': [
                '01110',
                '10001',
                '11111',
                '10001',
                '10001'
            ],
            'd': [
                '11110',
                '10001',
                '10001',
                '10001',
                '11110'
            ],
            'z': [
                '11111',
                '00110',
                '01100',
                '11000',
                '11111'
            ],
            'i': [
                '11111',
                '00100',
                '00100',
                '00100',
                '11111'
            ],
            '.': [
                '00000',
                '00000',
                '00000',
                '01100',
                '01100'
            ],
            'o': [
                '01110',
                '10001',
                '10001',
                '10001',
                '01110'
            ]
        };

        // Fixed color pattern for text
        const colorPattern = [
            '#FF0080', // Pink
            '#00FF80', // Cyan
            '#8000FF', // Purple
            '#FF8000', // Orange
            '#00FFFF', // Aqua
            '#FF00FF', // Magenta
            '#FFFF00'  // Yellow
        ];

        function getColorForPosition(x, y) {
            // Use position to deterministically select color
            const index = Math.abs(x + y * 7) % colorPattern.length;
            return colorPattern[index];
        }

        function createBgTile(x, y, grid) {
            const tile = document.createElement('div');
            tile.className = 'bg-tile';
            
            // Fixed tile size
            const width = bgTileSize;
            const height = bgTileSize;
            
            // Use seeded random for consistent but irregular placement
            const seed = x * 10000 + y;
            const random = (seed) => {
                const x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            };
            
            // Calculate maximum safe variation (half a tile size)
            const maxVariation = bgTileSize * 0.5;
            
            // Try multiple positions within the cell
            const maxAttempts = 10;
            let finalX = x, finalY = y;
            let placed = false;
            
            for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
                // Reduce variation range and ensure minimum spacing
                const variationX = (random(seed + attempt) - 0.5) * maxVariation;
                const variationY = (random(seed + attempt + 1000) - 0.5) * maxVariation;
                
                const tryX = x + variationX;
                const tryY = y + variationY;
                
                if (!isOverlapping(tryX, tryY, width, height, grid)) {
                    finalX = tryX;
                    finalY = tryY;
                    placed = true;
                }
            }
            
            // If we couldn't find a non-overlapping position, use the original grid position
            if (!placed) {
                finalX = x;
                finalY = y;
            }
            
            // Update grid with final position
            const gridX = Math.floor(finalX / bgTileSize);
            const gridY = Math.floor(finalY / bgTileSize);
            grid[`${gridX},${gridY}`] = { x: finalX, y: finalY, width, height };
            
            tile.style.width = `${width}px`;
            tile.style.height = `${height}px`;
            tile.style.left = `${finalX}px`;
            tile.style.top = `${finalY}px`;
            
            return tile;
        }

        function isOverlapping(x, y, width, height, grid) {
            const margin = bgTileSize * 0.2; // 20% of tile size as minimum spacing
            
            // Check nearby grid cells for potential overlaps
            const startGridX = Math.floor((x - width - margin) / bgTileSize) - 1;
            const endGridX = Math.ceil((x + width + margin) / bgTileSize) + 1;
            const startGridY = Math.floor((y - height - margin) / bgTileSize) - 1;
            const endGridY = Math.ceil((y + height + margin) / bgTileSize) + 1;
            
            for (let gridY = startGridY; gridY <= endGridY; gridY++) {
                for (let gridX = startGridX; gridX <= endGridX; gridX++) {
                    const key = `${gridX},${gridY}`;
                    const tile = grid[key];
                    if (tile) {
                        // Check if rectangles overlap with margin
                        if (!(x + width + margin < tile.x || 
                            x > tile.x + tile.width + margin || 
                            y + height + margin < tile.y || 
                            y > tile.y + tile.height + margin)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function createTextPixel(x, y, color, isGray = false) {
            const pixel = document.createElement('div');
            pixel.className = 'text-pixel';
            pixel.style.left = `${x}px`;
            pixel.style.top = `${y}px`;
            pixel.style.width = `${pixelSize}px`;
            pixel.style.height = `${pixelSize}px`;
            
            if (isGray) {
                // Fixed gray gradient
                pixel.style.background = `linear-gradient(135deg, 
                    rgba(180, 180, 180, 0.9) 0%, 
                    rgba(100, 100, 100, 0.9) 100%)`;
            } else {
                // Create gradient based on the fixed color
                const rgb = hexToRgb(color);
                const lighter = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)`;
                const darker = `rgba(${Math.max(0, rgb.r - 50)}, ${Math.max(0, rgb.g - 50)}, ${Math.max(0, rgb.b - 50)}, 1)`;
                pixel.style.background = `linear-gradient(135deg, ${lighter} 0%, ${darker} 100%)`;
            }
            
            return pixel;
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function renderBackground() {
            const container = document.getElementById('background');
            container.innerHTML = '';
            
            const grid = {};
            // Add extra columns and rows to account for variations
            const cols = Math.ceil(window.innerWidth / bgTileSize) + 2;
            const rows = Math.ceil(window.innerHeight / bgTileSize) + 2;
            
            // Offset the starting position to center the grid
            const startX = -bgTileSize;
            const startY = -bgTileSize;

            // Create tiles with irregular placement
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const tile = createBgTile(
                        startX + x * bgTileSize,
                        startY + y * bgTileSize,
                        grid
                    );
                    container.appendChild(tile);
                }
            }
        }

        function renderText() {
            const wrapper = document.getElementById('text-wrapper');
            wrapper.innerHTML = '';
            let totalWidth = 0;
            let totalHeight = 5 * pixelSize;
            const textPixels = new Set();
            let textBounds = {
                minX: Infinity,
                maxX: -Infinity,
                minY: Infinity,
                maxY: -Infinity
            };

            // Calculate total width
            text.split('').forEach(char => {
                if (!letters[char]) return;
                const pattern = letters[char];
                totalWidth += (pattern[0].length + 1) * pixelSize;
            });

            // Scale to fit viewport
            const maxWidth = window.innerWidth * 0.8;
            const maxHeight = window.innerHeight * 0.5;
            const scaleX = maxWidth / totalWidth;
            const scaleY = maxHeight / totalHeight;
            const scale = Math.min(scaleX, scaleY);

            pixelSize = Math.floor(pixelSize * scale);
            let xOffset = -totalWidth * scale / 2;

            // First pass: collect text positions and bounds
            text.split('').forEach(char => {
                if (!letters[char]) return;
                const pattern = letters[char];
                pattern.forEach((row, y) => {
                    for (let x = 0; x < row.length; x++) {
                        if (row[x] === '1') {
                            const posX = x * pixelSize + xOffset;
                            const posY = y * pixelSize - (totalHeight * scale / 2);
                            textPixels.add(`${posX},${posY}`);
                            
                            // Update bounds
                            textBounds.minX = Math.min(textBounds.minX, posX);
                            textBounds.maxX = Math.max(textBounds.maxX, posX + pixelSize);
                            textBounds.minY = Math.min(textBounds.minY, posY);
                            textBounds.maxY = Math.max(textBounds.maxY, posY + pixelSize);
                        }
                    }
                });
                xOffset += (pattern[0].length + 1) * pixelSize;
            });

            // Calculate extended bounds for gray tiles
            const padding = pixelSize * 3;
            const extendedBounds = {
                minX: Math.floor(textBounds.minX / pixelSize) * pixelSize - padding,
                maxX: Math.ceil(textBounds.maxX / pixelSize) * pixelSize + padding,
                minY: Math.floor(textBounds.minY / pixelSize) * pixelSize - padding,
                maxY: Math.ceil(textBounds.maxY / pixelSize) * pixelSize + padding
            };

            // Create gray tiles in the extended area
            for (let y = extendedBounds.minY; y <= extendedBounds.maxY; y += pixelSize) {
                for (let x = extendedBounds.minX; x <= extendedBounds.maxX; x += pixelSize) {
                    const pos = `${x},${y}`;
                    if (!textPixels.has(pos)) {
                        // Check if position is near any text pixel
                        let shouldAddGray = false;
                        const checkRadius = 3;
                        
                        for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                            for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                                const checkPos = `${x + dx * pixelSize},${y + dy * pixelSize}`;
                                if (textPixels.has(checkPos)) {
                                    shouldAddGray = true;
                                    break;
                                }
                            }
                            if (shouldAddGray) break;
                        }
                        
                        if (shouldAddGray) {
                            const pixel = createTextPixel(x, y, null, true);
                            wrapper.appendChild(pixel);
                        }
                    }
                }
            }

            // Reset xOffset for rendering colored text pixels
            xOffset = -totalWidth * scale / 2;

            // Final pass: render colored text pixels on top
            text.split('').forEach(char => {
                if (!letters[char]) return;
                const pattern = letters[char];
                pattern.forEach((row, y) => {
                    for (let x = 0; x < row.length; x++) {
                        if (row[x] === '1') {
                            const posX = x * pixelSize + xOffset;
                            const posY = y * pixelSize - (totalHeight * scale / 2);
                            const color = getColorForPosition(x, y);
                            const pixel = createTextPixel(posX, posY, color);
                            wrapper.appendChild(pixel);
                        }
                    }
                });
                xOffset += (pattern[0].length + 1) * pixelSize;
            });
        }

        renderBackground();
        renderText();

        // Only resize event, no animations
        window.addEventListener('resize', () => {
            renderBackground();
            renderText();
        });
    </script>
</body>
</html>
